import assetra
from assetra.system import EnergySystemBuilder
from assetra.units import StochasticUnit
from assetra.units import StorageUnit
from assetra.units import EnergyUnit
from assetra.system import EnergySystem
from pathlib import Path
import xarray as xr
import pandas as pd
import numpy as np 
from logging import getLogger


# ENERGY UNIT(S)
MAX_CHUNK_SIZE = int(1e8)

# Fetch the original StorageUnit class from assetra
OriginalStorageUnit = StorageUnit

# Define the custom StorageUnit class with optional forced outage rate
class CustomStorageUnit(OriginalStorageUnit):
    """Derived energy unit class with optional forced outage rate.

    A storage unit that includes a forced outage rate, similar to
    StochasticUnit. The forced outage rate is optional.

    Args:
        id (int): Unique identifying number
        nameplate_capacity (float): Nameplate capacity in units of power.
        charge_rate (float): Charge rate in units of power
        discharge_rate (float): Discharge rate in units of power
        charge_capacity (float): Maximum charge capacity in units of energy
        roundtrip_efficiency (float): Roundtrip efficiency as decimal percent
        hourly_forced_outage_rate (xr.DataArray, optional): Hourly forced
            outage rate as decimal percents (e.g. 5% -> 0.05) contained in
            DataArray with dimension (time) and datetime coordinates.
    """
    
    def __init__(self, id, nameplate_capacity, charge_rate, discharge_rate, charge_capacity, roundtrip_efficiency, hourly_forced_outage_rate=None):
        super().__init__(id, nameplate_capacity, charge_rate, discharge_rate, charge_capacity, roundtrip_efficiency)
        self.hourly_forced_outage_rate = hourly_forced_outage_rate

    @staticmethod
    def to_unit_dataset(units: list["CustomStorageUnit"]) -> xr.Dataset:
        dataset = OriginalStorageUnit.to_unit_dataset(units)
        if any(unit.hourly_forced_outage_rate is not None for unit in units):
            # Ensure coordinates and dimensions are properly set for forced outage rates
            hourly_forced_outage_rate_values = [
                unit.hourly_forced_outage_rate if unit.hourly_forced_outage_rate is not None 
                else xr.DataArray(np.zeros_like(units[0].hourly_forced_outage_rate.values), dims=units[0].hourly_forced_outage_rate.dims, coords=units[0].hourly_forced_outage_rate.coords) 
                for unit in units
            ]
            dataset['hourly_forced_outage_rate'] = xr.concat(hourly_forced_outage_rate_values, dim="energy_unit")
        return dataset

    @staticmethod
    def from_unit_dataset(unit_dataset: xr.Dataset) -> list["CustomStorageUnit"]:
        base_units = OriginalStorageUnit.from_unit_dataset(unit_dataset)
        units = []
        for idx, unit in enumerate(base_units):
            # Use .isel() instead of .loc() to properly index by position
            hourly_forced_outage_rate = unit_dataset.hourly_forced_outage_rate.isel(energy_unit=idx) if 'hourly_forced_outage_rate' in unit_dataset else None
            units.append(
                CustomStorageUnit(
                    unit.id,
                    unit.nameplate_capacity,
                    unit.charge_rate,
                    unit.discharge_rate,
                    unit.charge_capacity,
                    unit.roundtrip_efficiency,
                    hourly_forced_outage_rate
                )
            )
        return units
    @staticmethod
    def _get_hourly_capacity(
        charge_rate, discharge_rate, charge_capacity, roundtrip_efficiency, state_of_charge, net_demand, current_hour
    ):
        if net_demand < 0:  # Charging
            # Maximum charge limited by charge rate and remaining capacity
            max_charge = min(charge_rate, charge_capacity - state_of_charge)
            return min(max_charge, -net_demand)*roundtrip_efficiency
        else:  # Discharging
            # Maximum discharge limited by discharge rate and state of charge
            max_discharge = min(discharge_rate, state_of_charge)
            return min(max_discharge, net_demand)*roundtrip_efficiency

    @staticmethod
    def get_probabilistic_capacity_matrix(
        unit_dataset: xr.Dataset, net_hourly_capacity_matrix: xr.DataArray
    ) -> xr.DataArray:
        """Return probabilistic hourly capacity matrix for a storage unit
        dataset, adjusted for forced outage rates.

        For storage units, it is necessary to dispatch units every hour and
        iteration sequentially. The dispatch policy implemented in
        StorageUnit._get_hourly_capacity is a greedy policy to minimize
        expected unserved energy. Units are dispatched according to the order
        they appear in the unit dataset.

        Args:
            unit_dataset (xr.Dataset): Storage unit dataset, as generated by
                StorageUnit.to_unit_dataset function
            net_hourly_capacity_matrix (xr.DataArray): Probabilistic net hourly
                capacity matrix with dimensions (trials, time) and shape
                (# of trials, # of hours)

        Returns:
            xr.DataArray: Action matrix showing charging/discharging amounts
                for all units in the unit dataset with the same dimensions and
                shape as net hourly capacity matrix
        """
        # Extract units from the dataset
        units = CustomStorageUnit.from_unit_dataset(unit_dataset)

        # Initialize action matrix with zeros
        action_matrix = xr.zeros_like(net_hourly_capacity_matrix)

        for idx, unit in enumerate(units):
            LOG.info(
                "Dispatching storage unit "
                + str(idx)
                + " of "
                + str(len(units))
                + " in all hours"
            )
            
            # Forced outage rate array for the unit, default to zero if not provided
            forced_outage_rate = unit.hourly_forced_outage_rate if unit.hourly_forced_outage_rate is not None else xr.DataArray(np.zeros(len(net_hourly_capacity_matrix.time)))
            
            # Initial state of charge
            state_of_charge = 0.0

            for trial_idx, trial in enumerate(net_hourly_capacity_matrix):
                for hour in range(len(trial)):
                    net_demand = trial[hour].values

                    # Calculate the hourly capacity
                    capacity = CustomStorageUnit._get_hourly_capacity(
                        unit.charge_rate,
                        unit.discharge_rate,
                        unit.charge_capacity,
                        unit.roundtrip_efficiency,
                        state_of_charge,
                        net_demand,
                        hour
                    )

                    # Adjust capacity based on the forced outage rate
                    adjusted_capacity = capacity * (1 - forced_outage_rate[hour].values)

                    if net_demand < 0:  # Charging
                        state_of_charge += adjusted_capacity
                        state_of_charge = min(state_of_charge, unit.charge_capacity)
                        # Record the adjusted action in the action matrix
                        action_matrix[trial_idx, hour] += adjusted_capacity
                    else:  # Discharging
                        state_of_charge -= adjusted_capacity
                        state_of_charge = max(state_of_charge, 0)
                        # Record the adjusted action in the action matrix
                        action_matrix[trial_idx, hour] += -adjusted_capacity

                    

        return action_matrix

from assetra.units import EnergyUnit
import xarray as xr
import numpy as np
from logging import getLogger

LOG = getLogger(__name__)

class HydroUnit(EnergyUnit):
    
    def __init__(self, id, nameplate_capacity, monthly_expected_generation, hourly_forced_outage_rate=None):
        super().__init__(id, nameplate_capacity)
        self.monthly_expected_generation = monthly_expected_generation
        self.hourly_forced_outage_rate = hourly_forced_outage_rate

    def _get_hourly_capacity(self, net_hourly_capacity: xr.DataArray) -> xr.DataArray:
        hourly_capacity = xr.zeros_like(net_hourly_capacity)
        grouped = net_hourly_capacity.groupby('time.month')

        for month, data in grouped:
            current_charge = float(self.monthly_expected_generation.sel(month=month, method='pad'))
            total_monthly_net_capacity = data.where(data < 0).sum().item()

            #print(f"Month: {month}, Current Charge: {current_charge}, Total Monthly Net Capacity: {total_monthly_net_capacity}")

            if total_monthly_net_capacity == 0:
                continue

            for i, net_capacity in enumerate(data):
                if net_capacity.item() >= 0:
                    dispatch_amount = 0
                else:
                    proportion = net_capacity.item() / total_monthly_net_capacity
                    dispatch_amount = proportion * current_charge
                    dispatch_amount = min(dispatch_amount, self.nameplate_capacity)
                hourly_capacity.loc[data.time[i]] = dispatch_amount

                #print(f"Time: {data.time[i]}, Net Capacity: {net_capacity.item()}, Dispatch Amount: {dispatch_amount}")

            #print(f"Hourly Capacity for month {month}: {hourly_capacity.loc[data.time]}")
        return hourly_capacity

    @staticmethod
    def to_unit_dataset(units: list["HydroUnit"]) -> xr.Dataset:
        months = np.arange(1, 13) #only works for one year at a time 
        hourly_time = units[0].hourly_forced_outage_rate.time if units[0].hourly_forced_outage_rate is not None else None
        
        dataset = xr.Dataset({
            "nameplate_capacity": (["energy_unit"], [unit.nameplate_capacity for unit in units]),
            "monthly_expected_generation": (["energy_unit", "month"], [unit.monthly_expected_generation.values for unit in units])
        })

        if hourly_time is not None:
            dataset = dataset.assign_coords({"hourly_time": hourly_time})
        
        if any(unit.hourly_forced_outage_rate is not None for unit in units):
            hourly_rates = [
                unit.hourly_forced_outage_rate.values if unit.hourly_forced_outage_rate is not None else np.zeros(hourly_time.shape)
                for unit in units
            ]
            dataset["hourly_forced_outage_rate"] = (["energy_unit", "hourly_time"], hourly_rates)
        
        dataset = dataset.assign_coords({"month": months})
        #print(dataset)
        return dataset

    @staticmethod
    def from_unit_dataset(unit_dataset: xr.Dataset) -> list["HydroUnit"]:
        units = []
        for idx in range(len(unit_dataset.energy_unit)):
            hourly_forced_outage_rate = None
            if "hourly_forced_outage_rate" in unit_dataset:
                hourly_forced_outage_rate = xr.DataArray(
                    unit_dataset["hourly_forced_outage_rate"].isel(energy_unit=idx).values,
                    dims=["time"],
                    coords={"time": unit_dataset.hourly_time.values}
                )
                
            monthly_coords = np.arange(1, 13) 
            monthly_expected_generation = xr.DataArray(
                unit_dataset["monthly_expected_generation"].isel(energy_unit=idx).values,
                dims=["month"],
                coords={"month": monthly_coords}
            )

            units.append(
                HydroUnit(
                    id=unit_dataset.energy_unit[idx].item(),
                    nameplate_capacity=unit_dataset.nameplate_capacity[idx].item(),
                    monthly_expected_generation=monthly_expected_generation,
                    #hourly_forced_outage_rate=hourly_forced_outage_rate
                )
            )
        return units

    @staticmethod
    def get_probabilistic_capacity_matrix(unit_dataset: xr.Dataset, net_hourly_capacity_matrix: xr.DataArray) -> xr.DataArray:
        units = HydroUnit.from_unit_dataset(unit_dataset)
        net_adj_hourly_capacity_matrix = net_hourly_capacity_matrix.copy()

        for idx, unit in enumerate(units):
            LOG.info("Dispatching hydro unit " + str(idx) + " of " + str(len(units)) + " in all hours")

            for trial in range(net_adj_hourly_capacity_matrix.sizes['trial']):
                net_capacity_trial = net_adj_hourly_capacity_matrix.isel(trial=trial)
                
                #print(f"Trial: {trial}, Net Hourly Capacity: {net_capacity_trial}")
                if unit.hourly_forced_outage_rate is not None:
                    outage_mask = np.random.random_sample(net_capacity_trial.shape) > unit.hourly_forced_outage_rate[:-1]
                else:
                    outage_mask = np.ones_like(net_capacity_trial)

                available_capacity = unit._get_hourly_capacity(net_capacity_trial)

                #print(f"Trial: {trial}, Available Capacity before outage: {available_capacity}")

                adjusted_capacity = available_capacity * outage_mask

                net_adj_hourly_capacity_matrix.loc[dict(trial=trial)] += adjusted_capacity

                #print(f"Trial: {trial}, Adjusted Capacity after outage: {adjusted_capacity}")
                #print(net_adj_hourly_capacity_matrix - net_hourly_capacity_matrix)
        return net_adj_hourly_capacity_matrix - net_hourly_capacity_matrix 
        
        

# Ensure `HydroUnit` is added to the list of responsive unit types in `assetra.units`
#from assetra import units
#units.RESPONSIVE_UNIT_TYPES.append(HydroUnit)

#SOLAR AND WIND UNIT 
class SolarandWindUnit(EnergyUnit):
    """Derived energy unit class.

    A stochastic energy unit uses time-varying forced outage rates to sample
    indepenedent outages throughout the simulation period. Stochastic units are
    non-responsive, meaning that while hourly capacity profiles vary between
    trials in a probabilistic simulation, the profiles do not depend on system
    conditions and only need to be sampled once

    Args:
        id (int): Unique identifying number
        nameplate_capacity (float) : Nameplate capacity of the energy unit in
            units of power
        hourly_capacity (xr.DataArray) : Hourly capacity contained in DataArray
            with dimension (time) and datetime coordinates
        hourly_forced_outage_rate (xr.DataArray) : Hourly forced outage rate
            as decimal percents (e.g. 5% -> 0.05) contained in DataArray with
            dimension (time) and datetime coordinates. Should be a parallel
            matrix to hourly_capacity
    """

    hourly_capacity: xr.DataArray
    hourly_forced_outage_rate: xr.DataArray
    def __init__(self, id, nameplate_capacity, hourly_capacity, hourly_forced_outage_rate):
        super().__init__(id, nameplate_capacity)  # Initialize the attributes handled by EnergyUnit
        self.hourly_capacity = hourly_capacity     # Handle specific attributes for SolarandWindUnit
        self.hourly_forced_outage_rate = hourly_forced_outage_rate
        

    @staticmethod
    def to_unit_dataset(units: list[StochasticUnit]):
        """Convert a list of stochastic energy units into an xarray dataset

        Args:
            units (list[StochasticUnit]): List of of stochastic energy units

        Returns:
            xr.Dataset: Dataset with dimensions (energy_unit, time) and
                variables (nameplate_capacity[energy_unit],
                hourly_capacity[energy_unit, time]),
                hourly_forced_outage_rate[energy_unit, time]. Coordinates for
                the energy_unit and time dimensions are energy unit IDs and
                hourly datetime indices, respectively.
        """
        unit_dataset = xr.Dataset(
            data_vars=dict(
                nameplate_capacity=(
                    ["energy_unit"],
                    [unit.nameplate_capacity for unit in units],
                ),
                hourly_capacity=(
                    ["energy_unit", "time"],
                    [unit.hourly_capacity for unit in units],
                ),
                hourly_forced_outage_rate=(
                    ["energy_unit", "time"],
                    [unit.hourly_forced_outage_rate for unit in units],
                ),
            ),
            coords=dict(
                energy_unit=[unit.id for unit in units],
                time=units[0].hourly_capacity.time if len(units) > 0 else [],
            ),
        )
        return unit_dataset

    @staticmethod
    def from_unit_dataset(unit_dataset: xr.Dataset) -> list[StochasticUnit]:
        """Convert a stochastic unit dataset to a list of stochastic energy units.

        This is the inverse to StochasticUnit.to_unit_dataset function

        Args:
            unit_dataset (xr.Dataset): Unit dataset with structure and content
                defined in the derived StochasticUnit.to_unit_dataset function

        Returns:
            list[StochasticUnit]: List of stochastic units
        """
        # build list
        units = []

        for id in unit_dataset.energy_unit:
            units.append(
                StochasticUnit(
                    id,
                    unit_dataset.nameplate_capacity.loc[id],
                    unit_dataset.hourly_capacity.loc[id],
                    unit_dataset.hourly_forced_outage_rate.loc[id],
                )
            )

        return units

    @staticmethod
    def get_probabilistic_capacity_matrix(
        unit_dataset: xr.Dataset, net_hourly_capacity_matrix: xr.DataArray
    ) -> xr.DataArray:
        """Return probabilistic hourly capacity matrix for a stochastic unit
        dataset.

        For stochastic units, sample hourly independent outages in for units
        in all trials. Outages are sampled hourly for every unit and trial.
        Random numbers are drawn from the range 0 to 1, and where samples are
        less than the hourly forced outage rate, the effective capacity of
        that energy unit in that hour and trial is set to 0. The probabilistic
        capacity matrix is the aggregation of sampled capacities across energy
        units

        Args:
            unit_dataset (xr.Dataset): Static unit dataset, as generated by
                StaticUnit.to_unit_dataset function
            net_hourly_capacity_matrix (xr.DataArray): Probabilistic net hourly
                capacity matrix with dimensions (trials, time) and shape
                (# of trials, # of hours)

        Returns:
            xr.DataArray: Combined hourly capacity for all units in the unit
                dataset with the same dimensions and shape as net hourly
                capacity matrix
        """
        # time-indexing
        unit_dataset = unit_dataset.sel(time=net_hourly_capacity_matrix.time)

        chunk_size = 1 + MAX_CHUNK_SIZE // (
            net_hourly_capacity_matrix.sizes["trial"]
            * net_hourly_capacity_matrix.sizes["time"]
        )
        LOG.info("Using chunk size " + str(chunk_size))

        # Initialize the probabilistic capacity matrix
        probabilistic_capacity_matrix = xr.zeros_like(
            net_hourly_capacity_matrix
        )

        # Loop over the energy unit dimension in chunks
        for unit_idx in range(0, unit_dataset.sizes["energy_unit"], chunk_size):
            unit_idx_end = min(
                unit_idx + chunk_size, unit_dataset.sizes["energy_unit"]
            )

            LOG.info(
                "Sampling outages for units "
                + str(unit_idx + 1)
                + "-"
                + str(unit_idx_end)
                + " of "
                + str(unit_dataset.sizes["energy_unit"])
            )

            chunk = unit_dataset.isel(energy_unit=slice(unit_idx, unit_idx_end))

            chunk_prob_matrix = np.where(
                np.random.random_sample(
                    (
                        net_hourly_capacity_matrix.sizes["trial"],
                        chunk.sizes["energy_unit"],
                        net_hourly_capacity_matrix.sizes["time"],
                    )
                )
                > chunk["hourly_forced_outage_rate"].values,
                chunk["hourly_capacity"].values,
                0,
            ).sum(axis=1)

            # Update the main probabilistic capacity matrix with the results from the chunk
            probabilistic_capacity_matrix += chunk_prob_matrix

        return probabilistic_capacity_matrix
